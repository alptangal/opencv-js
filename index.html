<!DOCTYPE html>
<html>

<body>
  <h1>hello world</h1>
  <p id="result1"></p>
  <p id="result"></p>
  <img style="display:none;" id="img" crossorigin="anonymous"
    src="https://raw.githubusercontent.com/undecaf/zbar-wasm/master/tests/img/qr_code.png">
  <video playsinline autoplay></video>

  <pre id="result"></pre>
  <script type="module">
    import { BarcodeDetectorPolyfill } from "https://cdn.jsdelivr.net/npm/@undecaf/barcode-detector-polyfill@latest/dist/main.js";
    let result1 = document.getElementById('result1')
    let result = document.getElementById('result')
    let canvas = document.createElement('canvas')
    let ctx = canvas.getContext('2d')
    let video = document.querySelector("video")
    let requestId = null
    let detect = null
    async function createDetector() {
      //supportedFormats = await BarcodeDetectorPolyfill.getSupportedFormats()
      const st='codabar, code_39, code_93, code_128, databar, databar_exp, ean_2, ean_5, ean_8, ean_13, ean_13+2, ean_13+5, isbn_10, isbn_13, isbn_13+2, isbn_13+5, itf, qr_code, sq_code, upc_a, upc_e'.split(', ')
      detect = new BarcodeDetectorPolyfill({ formats: st, zbar: { encoding: 'utf-8"' } })
    }
    function dectectVideo(source){
      return detect
        .detect(source)
        .then(symbols => {
            canvas.width = source.naturalWidth || source.videoWidth || source.width
            canvas.height = source.naturalHeight || source.videoHeight || source.height
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            symbols.forEach(symbol => {
                const lastCornerPoint = symbol.cornerPoints[symbol.cornerPoints.length - 1]
                ctx.moveTo(lastCornerPoint.x, lastCornerPoint.y)
                symbol.cornerPoints.forEach(point => ctx.lineTo(point.x, point.y))

                ctx.lineWidth = 3
                ctx.strokeStyle = '#00e000ff'
                ctx.stroke()
            })

            if (!el.details.checked) {
                symbols.forEach(symbol => {
                    delete symbol.boundingBox
                    delete symbol.cornerPoints
                })
            }
            result1.innerText = JSON.stringify(symbols, null, 2)
        })
    }
    createDetector()
    const constraints = {
      audio: false,
      video: {
        facingMode: "environment" 
      }
    }
    async function detector(repeat) {
      if (!repeat) {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }

      if (typeof repeat === 'undefined') {
        repeat = true
      }

      if (repeat) {
        result1.innerText = Date.now()
        
        dectectVideo(video).then(() => requestId = requestAnimationFrame(() => detector(true))).catch(error=>{result.innerHTML=error})

      } else {
        cancelAnimationFrame(requestId)
        requestId = null
      }
    }

    (async () => {

      const
        img = document.getElementById('img'),
        result = document.getElementById('result')





      /*
    
  await img.decode()
  canvas.width = img.naturalWidth
  canvas.height = img.naturalHeight
  context.drawImage(img, 0, 0)

  const
    imageData = context.getImageData(0, 0, canvas.width, canvas.height),
    symbols = await zbarWasm.scanImageData(imageData);
  
  symbols.forEach(s => s.rawData = s.decode())
  result.innerText = JSON.stringify(symbols, null, 2)
  */

      if (!requestId) {
        await navigator.mediaDevices.getUserMedia(constraints).then(stream => {
          video.srcObject = stream
          detector()
        }).catch(error => {
          console.log(error)
          result1.innerHTML = '<span style="color:red;">Error: </span>' + error
        })
      }
      else {
        detector(false)
      }
    })()
  </script>
</body>

</html>